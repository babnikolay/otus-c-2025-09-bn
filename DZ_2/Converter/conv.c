#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>

/* Map tables: for bytes 0x80..0xFF -> Unicode code points.
   Entries with 0 mean "direct 0x80..0xFF not used" but in given encodings none map to 0.
   Tables derived from standard mappings.
*/

/* CP1251 (Windows-1251) mapping for 0x80..0xFF */
static const uint16_t map_cp1251[128] = {
    0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,
    0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,
    0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,
    0x0098,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,
    0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,
    0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,
    0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,
    0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,
    0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,
    0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,
    0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,
    0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,
    0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,
    0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,
    0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,
    0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F
};

/* KOI8-R mapping 0x80..0xFF */
static const uint16_t map_koi8r[128] = {
    0x2500,0x2502,0x250C,0x2510,0x2514,0x2518,0x251C,0x2524,
    0x252C,0x2534,0x253C,0x2580,0x2584,0x2588,0x258C,0x2590,
    0x2591,0x2592,0x2593,0x2320,0x25A0,0x2219,0x221A,0x2248,
    0x2264,0x2265,0x00A0,0x2321,0x00B0,0x00B2,0x00B7,0x00F7,
    0x2550,0x2551,0x2552,0x0451,0x2553,0x2554,0x2555,0x2556,
    0x2557,0x2558,0x2559,0x255A,0x255B,0x255C,0x255D,0x255E,
    0x255F,0x2560,0x2561,0x0401,0x2562,0x2563,0x2564,0x2565,
    0x2566,0x2567,0x2568,0x2569,0x256A,0x256B,0x256C,0x00A9,
    0x044E,0x0430,0x0431,0x0446,0x0434,0x0435,0x0444,0x0433,
    0x0445,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,
    0x043F,0x044F,0x0440,0x0441,0x0442,0x0443,0x0436,0x0432,
    0x044C,0x044B,0x0437,0x0448,0x044D,0x0449,0x0447,0x044A,
    0x042E,0x0410,0x0411,0x0426,0x0414,0x0415,0x0424,0x0413,
    0x0425,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,
    0x041F,0x042F,0x0420,0x0421,0x0422,0x0423,0x0416,0x0412,
    0x042C,0x042B,0x0417,0x0428,0x042D,0x0429,0x0427,0x042A
};

/* ISO-8859-5 mapping 0xA0..0xFF (0x80..0x9F are control or unused) */
/* We'll map 0x80..0xFF by offset: for bytes 0xA0..0xFF mapping to U+00A0..U+00FF for 0xA0..0xBF except Cyrillic starts at 0xA0? */
/* Simpler: explicit table for 0x80..0xFF */
static const uint16_t map_iso8859_5[128] = {
    /* 0x80 - 0x8F */
    0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,
    0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,
    /* 0x90 - 0x9F */
    0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,
    0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,
    /* 0xA0 - 0xAF */
    0x00A0,0x0401,0x0402,0x0403,0x0404,0x0405,0x0406,0x0407,
    0x0408,0x0409,0x040A,0x040B,0x040C,0x00AD,0x040E,0x040F,
    /* 0xB0 - 0xBF */
    0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,
    0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,
    /* 0xC0 - 0xCF */
    0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,
    0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,
    /* 0xD0 - 0xDF */
    0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,
    0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,
    /* 0xE0 - 0xEF */
    0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,
    0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F,
    /* 0xF0 - 0xFF */
    0x2116,0x0451,0x0452,0x0453,0x0454,0x0455,0x0456,0x0457,
    0x0458,0x0459,0x045A,0x045B,0x045C,0x00A7,0x045E,0x045F
};

/* Write a Unicode code point as UTF-8 into buffer. Return number of bytes written (1..4). */
static int utf8_encode(uint32_t cp, unsigned char out[4]) {
    if (cp <= 0x7F) {
        out[0] = (unsigned char)cp;
        return 1;
    } else if (cp <= 0x7FF) {
        out[0] = 0xC0 | (unsigned char)(cp >> 6);
        out[1] = 0x80 | (unsigned char)(cp & 0x3F);
        return 2;
    } else if (cp <= 0xFFFF) {
        out[0] = 0xE0 | (unsigned char)(cp >> 12);
        out[1] = 0x80 | (unsigned char)((cp >> 6) & 0x3F);
        out[2] = 0x80 | (unsigned char)(cp & 0x3F);
        return 3;
    } else {
        out[0] = 0xF0 | (unsigned char)(cp >> 18);
        out[1] = 0x80 | (unsigned char)((cp >> 12) & 0x3F);
        out[2] = 0x80 | (unsigned char)((cp >> 6) & 0x3F);
        out[3] = 0x80 | (unsigned char)(cp & 0x3F);
        return 4;
    }
}

enum enc_t { ENC_UNKNOWN = -1, ENC_CP1251, ENC_KOI8R, ENC_ISO8859_5 };

static enum enc_t detect_enc(const char *s) {
    if (strcmp(s, "cp1251") == 0 || strcmp(s, "CP1251") == 0 || strcmp(s, "windows-1251") == 0)
        return ENC_CP1251;
    if (strcmp(s, "koi8-r") == 0 || strcmp(s, "KOI8-R") == 0)
        return ENC_KOI8R;
    if (strcmp(s, "iso-8859-5") == 0 || strcmp(s, "iso8859-5") == 0 || strcmp(s, "ISO-8859-5") == 0)
        return ENC_ISO8859_5;
    return ENC_UNKNOWN; // Вернуть неизвестную кодировку
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <input file> <encoding> <output file>\n", argv[0]);
        return 2;
    }

    const char *inpath = argv[1];
    const char *encs = argv[2];
    const char *outpath = argv[3];

    enum enc_t enc = detect_enc(encs);
    if (enc < 0) {
        fprintf(stderr, "Unsupported encoding: %s\n", encs);
        return 3;
    }

    FILE *fin = fopen(inpath, "rb");
    if (!fin) {
        fprintf(stderr, "Error opening input file '%s': %s\n", inpath, strerror(errno));
        return 4;
    }
    FILE *fout = fopen(outpath, "wb");
    if (!fout) {
        fprintf(stderr, "Error opening output file '%s': %s\n", outpath, strerror(errno));
        fclose(fin);
        return 5;
    }

    unsigned char buf[4096];
    size_t r;
    while ((r = fread(buf, 1, sizeof buf, fin)) > 0) {
        size_t i;
        for (i = 0; i < r; ++i) {
            unsigned char b = buf[i];
            if (b < 0x80) {
                if (fputc(b, fout) == EOF) {
                    fprintf(stderr, "Write error: %s\n", strerror(errno));
                    fclose(fin); fclose(fout);
                    return 6;
                }
            } else {
                uint32_t cp = 0;
                if (enc == ENC_CP1251) {
                    cp = map_cp1251[b - 0x80];
                } else if (enc == ENC_KOI8R) {
                    cp = map_koi8r[b - 0x80];
                } else { /* ISO-8859-5 */
                    cp = map_iso8859_5[b - 0x80];
                }
                /* If mapping gives control (<=0xFF) and is not a Cyrillic, still encode */
                unsigned char out[4];
                int n = utf8_encode(cp, out);
                if (fwrite(out, 1, (size_t)n, fout) != (size_t)n) {
                    fprintf(stderr, "Write error: %s\n", strerror(errno));
                    fclose(fin); fclose(fout);
                    return 6;
                }
            }
        }
    }

    if (ferror(fin)) {
        fprintf(stderr, "Read error: %s\n", strerror(errno));
        fclose(fin); fclose(fout);
        return 7;
    }

    if (fclose(fin) != 0) {
        fprintf(stderr, "Error closing input file: %s\n", strerror(errno));
    }
    if (fclose(fout) != 0) {
        fprintf(stderr, "Error closing output file: %s\n", strerror(errno));
    }

    return 0;
}